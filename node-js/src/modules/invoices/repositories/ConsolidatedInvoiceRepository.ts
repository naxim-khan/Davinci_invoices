import { ClientKYC, Invoice, ConsolidatedInvoice, Prisma } from '@prisma/client';
import { logger } from '../../../common/utils/logger.util';
import { prisma } from '../../../core/database/prisma.client';

/**
 * Consolidated Invoice Repository
 *
 * Database access layer for consolidated invoice operations.
 * Handles complex queries and transactions with proper error handling.
 */
export class ConsolidatedInvoiceRepository {

    /**
     * Find all customers eligible for consolidated invoicing
     */
    async findEligibleCustomers(): Promise<ClientKYC[]> {
        return prisma.clientKYC.findMany({
            where: {
                billingPeriodEnabled: true,
                status: 'APPROVED',
                billingPeriodType: {
                    in: ['WEEKLY', 'MONTHLY'],
                },
            },
            orderBy: {
                id: 'asc',
            },
        });
    }

    /**
     * Find unconsolidated invoices for a customer in a specific period
     */
    async findUnconsolidatedInvoices(
        operatorId: number,
        periodStart: Date,
        periodEnd: Date,
    ): Promise<Invoice[]> {
        return prisma.invoice.findMany({
            where: {
                operatorId,
                issueDate: {
                    gte: periodStart,
                    lte: periodEnd,
                },
                includedInConsolidatedInvoiceId: null,
                status: {
                    not: 'CANCELLED',
                },
            },
            orderBy: {
                issueDate: 'asc',
            },
        });
    }

    /**
     * Check if a consolidated invoice already exists for this period
     */
    async findExistingConsolidatedInvoice(
        operatorId: number,
        periodStart: Date,
        periodEnd: Date,
    ): Promise<ConsolidatedInvoice | null> {
        return prisma.consolidatedInvoice.findFirst({
            where: {
                operatorId,
                billingPeriodStart: periodStart,
                billingPeriodEnd: periodEnd,
            },
        });
    }

    /**
     * Calculate aggregated totals for a billing period
     */
    async calculatePeriodTotals(
        invoices: Invoice[],
    ): Promise<{
        totalFlights: number;
        totalFeeUsd: number;
        totalOtherUsd: number;
        totalUsd: number;
        firsCrossed: string[];
        countries: string[];
    }> {
        const totalFlights = invoices.length;
        let totalFeeUsd = 0;
        let totalOtherUsd = 0;
        const firsSet = new Set<string>();
        const countriesSet = new Set<string>();

        for (const invoice of invoices) {
            totalFeeUsd += invoice.feeAmount || 0;

            // Handle otherFeesAmount which is stored as Json
            if (invoice.otherFeesAmount) {
                const otherFees = invoice.otherFeesAmount as any;
                if (typeof otherFees === 'number') {
                    totalOtherUsd += otherFees;
                } else if (typeof otherFees === 'object') {
                    // Sum all values if it's an object
                    totalOtherUsd += Object.values(otherFees).reduce((sum: number, val: any) => {
                        return sum + (typeof val === 'number' ? val : 0);
                    }, 0);
                }
            }

            if (invoice.firName) {
                firsSet.add(invoice.firName);
            }
            if (invoice.firCountry) {
                countriesSet.add(invoice.firCountry);
            }
        }

        return {
            totalFlights,
            totalFeeUsd,
            totalOtherUsd,
            totalUsd: totalFeeUsd + totalOtherUsd,
            firsCrossed: Array.from(firsSet),
            countries: Array.from(countriesSet),
        };
    }

    /**
     * Create consolidated invoice with line items in a transaction
     */
    async createConsolidatedInvoice(data: {
        invoiceNumber: string;
        issueDate: Date;
        dueDate: Date;
        operatorId: number;
        billingPeriodStart: Date;
        billingPeriodEnd: Date;
        billingPeriodType: 'WEEKLY' | 'MONTHLY';
        billedToName: string;
        billedToAddress: string | null;
        totalFlights: number;
        totalFeeUsd: number;
        totalOtherUsd: number;
        totalUsd: number;
        firsCrossed: string[];
        countries: string[];
        qrCodeData?: string | null;
        logoKey?: string | null;
        status: 'PENDING' | 'PAID' | 'CANCELLED' | 'DRAFT' | 'OVERDUE';
        autoGenerated: boolean;
        invoices: Invoice[];
    }): Promise<ConsolidatedInvoice> {
        return prisma.$transaction(async (tx) => {
            // Create consolidated invoice
            const consolidatedInvoice = await tx.consolidatedInvoice.create({
                data: {
                    invoiceNumber: data.invoiceNumber,
                    issueDate: data.issueDate,
                    dueDate: data.dueDate,
                    operatorId: data.operatorId,
                    billingPeriodStart: data.billingPeriodStart,
                    billingPeriodEnd: data.billingPeriodEnd,
                    billingPeriodType: data.billingPeriodType,
                    billedToName: data.billedToName,
                    billedToAddress: data.billedToAddress,
                    totalFlights: data.totalFlights,
                    totalFeeUsd: data.totalFeeUsd,
                    totalOtherUsd: data.totalOtherUsd,
                    totalUsd: data.totalUsd,
                    firsCrossed: data.firsCrossed,
                    countries: data.countries,
                    qrCodeData: data.qrCodeData,
                    logoKey: data.logoKey,
                    status: data.status,
                    autoGenerated: data.autoGenerated,
                    generatedAt: new Date(),
                    updatedAt: new Date(),
                },
            });

            // Create line items
            const lineItemsData = data.invoices.map((invoice) => ({
                consolidatedInvoiceId: consolidatedInvoice.id,
                invoiceId: invoice.id,
                invoiceNumber: invoice.invoiceNumber,
                act: invoice.act,
                date: invoice.flightDate || invoice.issueDate,
                time: invoice.firEntryTimeUtc?.toISOString(),
                url: `/invoices/${invoice.invoiceNumber}`,
                totalUsd: invoice.totalUsdAmount || 0,
                createdAt: new Date(),
                updatedAt: new Date(),
            }));

            await tx.consolidatedInvoiceLineItem.createMany({
                data: lineItemsData,
            });

            // Update individual invoices to mark them as consolidated
            await tx.invoice.updateMany({
                where: {
                    id: {
                        in: data.invoices.map((inv) => inv.id),
                    },
                },
                data: {
                    includedInConsolidatedInvoiceId: consolidatedInvoice.id,
                },
            });

            // Update customer tracking fields
            await tx.clientKYC.update({
                where: {
                    id: data.operatorId,
                },
                data: {
                    lastConsolidatedInvoiceGeneratedAt: new Date(),
                    lastBillingPeriodEnd: data.billingPeriodEnd,
                },
            });

            logger.info({
                msg: 'Consolidated invoice created successfully',
                consolidatedInvoiceId: consolidatedInvoice.id,
                invoiceNumber: consolidatedInvoice.invoiceNumber,
                operatorId: data.operatorId,
                totalFlights: data.totalFlights,
                totalUsd: data.totalUsd,
            });

            return consolidatedInvoice;
        });
    }

    /**
     * Get consolidated invoice by ID with line items
     */
    async findById(id: number): Promise<ConsolidatedInvoice | null> {
        return prisma.consolidatedInvoice.findUnique({
            where: { id },
            include: {
                ConsolidatedInvoiceLineItem: {
                    include: {
                        Invoice: true,
                    },
                    orderBy: {
                        date: 'asc',
                    },
                },
                ClientKYC: true,
            },
        });
    }

    /**
     * Get consolidated invoices for a customer with filters
     */
    async findByCustomer(
        operatorId: number,
        filters?: {
            startDate?: Date;
            endDate?: Date;
            status?: string;
            billingPeriodType?: 'WEEKLY' | 'MONTHLY';
        },
    ): Promise<ConsolidatedInvoice[]> {
        const where: Prisma.ConsolidatedInvoiceWhereInput = {
            operatorId,
        };

        if (filters?.startDate || filters?.endDate) {
            where.issueDate = {
                ...(filters.startDate ? { gte: filters.startDate } : {}),
                ...(filters.endDate ? { lte: filters.endDate } : {}),
            };
        }
        if (filters?.status) {
            where.status = filters.status as any;
        }
        if (filters?.billingPeriodType) {
            where.billingPeriodType = filters.billingPeriodType;
        }

        return prisma.consolidatedInvoice.findMany({
            where,
            include: {
                ConsolidatedInvoiceLineItem: {
                    orderBy: {
                        date: 'asc',
                    },
                },
            },
            orderBy: {
                issueDate: 'desc',
            },
        });
    }

    /**
     * Get customer by ID
     */
    async findCustomerById(id: number): Promise<ClientKYC | null> {
        return prisma.clientKYC.findUnique({
            where: { id },
        });
    }
}
